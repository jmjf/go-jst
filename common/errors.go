package common

import (
	"errors"
	"fmt"
	"path/filepath"
	"runtime"
)

// WrapError wraps an error with information about the WrapError caller.
// When bubbling up errors, this simplifies wrapping and ensures consistent
// lightweight stack traces.
func WrapError(err error) error {
	// get information about the function that called this one
	pc, file, line, ok := runtime.Caller(1)
	if !ok {
		return fmt.Errorf("unknown caller <- %w", err)
	}
	return fmt.Errorf("%s::%s::%d <- %w", filepath.Base(file), runtime.FuncForPC(pc).Name(), line, err)
}

// BaseError holds error data common to all errors
type BaseError struct {
	FileName string
	FuncName string
	LineNo   int
	Data     any
	Code     string
	Err      error
}

func (be *BaseError) Error() string {
	return fmt.Sprintf("%s::%s::%d Code %s | %v", be.FileName, be.FuncName, be.LineNo, be.Code, be.Err)
}

func (be *BaseError) Unwrap() error {
	return be.Err
}

// DomainError represents an error generated by domain layer code
type DomainError struct {
	BaseError
}

// NewDomainError creates a DomainError. It uses runtime.Caller(1) to get information
// about the caller to include in the error structure.
func NewDomainError(err error, code string, data any) *DomainError {
	// get information about the function that called this one
	pc, file, line, ok := runtime.Caller(1)

	newErr := DomainError{}
	newErr.Code = code
	newErr.Err = err
	newErr.Data = data
	if ok {
		newErr.FileName = filepath.Base(file)
		newErr.FuncName = runtime.FuncForPC(pc).Name()
		newErr.LineNo = line
	}
	return &newErr
}

// primitive errors and error codes for DomainError
var (
	ErrDomainProps   = errors.New("props error")
	ErrcdDomainProps = "PropsError"
)

// AppError represents an error generated by application layer code
type AppError struct {
	BaseError
}

func NewAppError(err error, code string, data any) *AppError {
	// get information about the function that called this one
	pc, file, line, ok := runtime.Caller(1)

	newErr := AppError{}
	newErr.Code = code
	newErr.Err = err
	newErr.Data = data
	if ok {
		newErr.FileName = filepath.Base(file)
		newErr.FuncName = runtime.FuncForPC(pc).Name()
		newErr.LineNo = line
	}
	return &newErr
}

// Primitive errors an error codes for AppError
var (
	ErrAppUnexpected   = errors.New("unexpected error")
	ErrcdAppUnexpected = "UnexpectedError"
)

// RepoError represents an error generated by a repo layer code
type RepoError struct {
	BaseError
}

func NewRepoError(err error, code string, data any) *RepoError {
	// get information about the function that called this one
	pc, file, line, ok := runtime.Caller(1)

	newErr := RepoError{}
	newErr.Code = code
	newErr.Err = err
	newErr.Data = data
	if ok {
		newErr.FileName = filepath.Base(file)
		newErr.FuncName = runtime.FuncForPC(pc).Name()
		newErr.LineNo = line
	}
	return &newErr
}

// Primitive errors an error codes for RepoError
var (
	ErrRepoScan            = errors.New("scan error")
	ErrcdRepoScan          = "ScanError"
	ErrRepoDupeRow         = errors.New("duplicate row error")
	ErrcdRepoDupeRow       = "DuplicateRowError"
	ErrRepoConnException   = errors.New("connection exception error")
	ErrcdRepoConnException = "ConnectionExceptionError"
	ErrRepoOther           = errors.New("other error")
	ErrcdRepoOther         = "RepoOtherError"
	// TODO: examine database error and classify it
	// should retry? etc.
)

// CtrlError represents an error generated by a controller (inbound adapter)
type CtrlError struct {
	BaseError
}

func NewCtrlError(err error, code string, data any) *CtrlError {
	// get information about the function that called this one
	pc, file, line, ok := runtime.Caller(1)

	newErr := CtrlError{}
	newErr.Code = code
	newErr.Err = err
	newErr.Data = data
	if ok {
		newErr.FileName = filepath.Base(file)
		newErr.FuncName = runtime.FuncForPC(pc).Name()
		newErr.LineNo = line
	}
	return &newErr
}

// Primitive errors and error codes for CtrlError
var (
	ErrJsonDecode   = errors.New("json decode error")
	ErrcdJsonDecode = "JsonDecodeError"
)

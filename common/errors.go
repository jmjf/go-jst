package common

import (
	"fmt"
	"path/filepath"
	"runtime"
)

// WrapError wraps an error with information about the WrapError caller.
// When bubbling up errors, this simplifies wrapping and ensures consistent
// lightweight stack traces.
func WrapError(err error) error {
	// get information about the function that called this one
	pc, file, line, ok := runtime.Caller(1)
	if !ok {
		return fmt.Errorf("unknown caller | %w", err)
	}
	return fmt.Errorf("%s.%s %d | %w", filepath.Base(file), runtime.FuncForPC(pc).Name(), line, err)
}

// DomainError holds error data for an error generated by domain layer code
type DomainError struct {
	FileName string
	FuncName string
	LineNo   int
	Data     any
	Code     string
	Err      error
}

func (de *DomainError) Error() string {
	return fmt.Sprintf("%s.%s %s | %v", de.FileName, de.FuncName, de.Code, de.Err)
}

func (de *DomainError) Unwrap() error {
	return de.Err
}

// NewDomainError creates a DomainError. It uses runtime.Caller(1) to get information
// about the caller to include in the error structure.
func NewDomainError(err error, code string, data any) *DomainError {
	// get information about the function that called this one
	pc, file, line, ok := runtime.Caller(1)

	de := DomainError{
		Code: code,
		Err:  err,
		Data: data,
	}
	if ok {
		de.FileName = filepath.Base(file)
		de.FuncName = runtime.FuncForPC(pc).Name()
		de.LineNo = line
	}
	return &de
}

// AppError represents an error generated by application layer code
type AppError struct {
	FileName string
	FuncName string
	LineNo   int
	Data     any
	Code     string
	Err      error
}

func (ae *AppError) Error() string {
	return fmt.Sprintf("%s.%s %s | %v", ae.FileName, ae.FuncName, ae.Code, ae.Err)
}

func (ae *AppError) Unwrap() error {
	return ae.Err
}

func NewAppError(err error, code string, data any) *AppError {
	// get information about the function that called this one
	pc, file, line, ok := runtime.Caller(1)

	ae := AppError{
		Code: code,
		Err:  err,
		Data: data,
	}
	if ok {
		ae.FileName = filepath.Base(file)
		ae.FuncName = runtime.FuncForPC(pc).Name()
		ae.LineNo = line
	}
	return &ae
}

// RepoError represents an error generated by application layer code
type RepoError struct {
	FileName string
	FuncName string
	LineNo   int
	Data     any
	Code     string
	Err      error
}

func (re *RepoError) Error() string {
	return fmt.Sprintf("%s.%s %s | %v", re.FileName, re.FuncName, re.Code, re.Err)
}

func (re *RepoError) Unwrap() error {
	return re.Err
}

func NewRepoError(err error, code string, data any) *RepoError {
	// get information about the function that called this one
	pc, file, line, ok := runtime.Caller(1)

	re := RepoError{
		Code: code,
		Err:  err,
		Data: data,
	}
	if ok {
		re.FileName = filepath.Base(file)
		re.FuncName = runtime.FuncForPC(pc).Name()
		re.LineNo = line
	}
	return &re
}

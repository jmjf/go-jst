# Interlude -- Reorganize server setup and startup

## Move repos up one level

Repos are in `jobStatus/db/*/repo.go`. I want to remove the `db` layer and prefix `*` with `db` so they're grouped and easier to get to.

* Move directories and renamed.
* Change test import paths. Tests pass.
* Change `cmd` import paths. Run `database/sql`/`pgx`, responses and logs as expected.

**COMMIT:** REFACTOR: move repos up one layer

I want to make the repo `New*()` methods generic so I can use the same call regardless of the repo I select.

* Change repo object to `repoDb` in all repos
* Change repo `New*()` to `NewRepoDb()`; change references in all repos
* Change test import paths. Tests pass.
* Change `cmd` import paths. Run `dbSqlPgx`, responses and logs as expected.

**COMMIT:** REFACTOR: make repo `New*()` methods generic

I want to move the database connection process into each repo so I can use the same call regardless of the ORM I select.

For tests, I need to pass a mock database connection. So, export the database handle `repo.DB`. Then in tests, I can set the database handle to the mock db.

* Change `NewRepoDb()` to accept a DSN string instead of a database connection object.
* Create repo `Open()` and `Close()`; `Open()` requires a pointer receiver so it can set `repo.DB`
* Change tests to set `repo.DB` to the mock.
* In `cmd/*/main.go`
  * Remove database connection code, keep URL/DSN setup.
  * Call `NewRepoDb()` with URL/DSN string.
  * Call repo `Open()`; defer repo `Close()`

`gorm` uses connection pools, so doesn't include a direct `Close()` method. I have to get the underlying `sql.DB` and call close on that. But this approach means each repo is opening (and closing) its own connection pool. That may not be a good idea. I need to investigate the consequences of having several repos and connection pools. `gorm`'s `NewRepoDb` may need to be different.

For `dbInMem`, `Open()` and `Close()` just return `nil`. There is nothing to open or close, so they're no-ops.

**COMMIT:** REFACTOR: move ORM/database specific open/close code into repos

## Name changes

Folks in the golang community like short variable, etc., names. I don't, usually. I'm making a pass through the repo code and applying the following changes. I'll apply to other parts of the code later.

* For receivers, aim for names 4 characters or less in lowercase. (This is counter Google practice, but I'm willing to fight on this point.)
* For parameters, use meaningful, spelled out names in camel-case with leading lowercase.
* For function local variables, use meaningful names or abbreviations, but prefer shorter names where possible.
* For other variables, constants and types, use meaningful, spelled out names in camel-case. Choose leading upper/lower casing based on exports.
* For package names, use all lower case with no separators (golang convention).
* For file names, use all lower case with underscore separators where meaningful or significant.
* For directory names, use all lower case with hyphen separators where meaningful or significant.
* For abbreviations, acronyms, initialisms, etc.
  * For multi-term, choose case for whole terms; first term of the name based on exportedness; case as in prose for the rest.
  * For lowercase letter in the term, if not exported, use all lower case, otherwise case first letter based on exportedness and the rest as prose.
  * Google's examples: (XMLAPI, xmlAPI; IOS, iOS; GRPC, gRPC; DDoS, ddos)
  * Exception: Id (identifier), classwords from database or JSON models in certain abbreviated structures
* For `New()` methods, favor `New()` if bound to the thing it's `New`ing (has a receiver); from "reduce repetition" section, which applies elsewhere

**COMMIT:** REFACTOR: apply name changes to repos; ensure tests run and `/cmd/*` has no lint errors

## Move route handler

Decide how server, routes, etc., relate to each other. I'd like to be able to assemble one or many sets of routes in `main` rather than making assumptions in the subdomain. So, I'll probably have `router.go` instead of `server.go` and it may be specific to the subdomain instead of having sub-routers in the subdomain. Decisions about authN/authZ can belong to `main` so I can have different deployables with different behaviors based on what I need. `main` may end up with a companion `server.go` that sets up the details of the server. I may be able to swap `server.go` for the same `main`.

I need to investigate how I might write tests that simulate an HTTP call and what they require so I ensure I separate everything correctly. I should be able to run those tests with mock database, HTTP, etc., connections. (These tests are close to e2e tests.) (`net/http/httptest`)

* Build `init()` for `jobStatus`.
* Move route handler setup to `jobStatus/http/<tbd>`
* Build a function to get routes to add to the server's handler
  * Accept a controller
* Change `cmd/*/main.go`
  * Get routes
  * Add to server

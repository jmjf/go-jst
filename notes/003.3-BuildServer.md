# Interlude -- Reorganize server setup and startup

## Move repos up one level

Repos are in `jobStatus/db/*/repo.go`. I want to remove the `db` layer and prefix `*` with `db` so they're grouped and easier to get to.

* Move directories and renamed.
* Change test import paths. Tests pass.
* Change `cmd` import paths. Run `database/sql`/`pgx`, responses and logs as expected.

**COMMIT:** REFACTOR: move repos up one layer

I want to make the repo `New*()` methods generic so I can use the same call regardless of the repo I select.

* Change repo object to `repoDb` in all repos
* Change repo `New*()` to `NewRepoDb()`; change references in all repos
* Change test import paths. Tests pass.
* Change `cmd` import paths. Run `dbSqlPgx`, responses and logs as expected.

**COMMIT:** REFACTOR: make repo `New*()` methods generic

I want to move the database connection process into each repo so I can use the same call regardless of the ORM I select.

For tests, I need to pass a mock database connection. So, export the database handle `repo.DB`. Then in tests, I can set the database handle to the mock db.

* Change `NewRepoDb()` to accept a DSN string instead of a database connection object.
* Create repo `Open()` and `Close()`; `Open()` requires a pointer receiver so it can set `repo.DB`
* Change tests to set `repo.DB` to the mock.
* In `cmd/*/main.go`
  * Remove database connection code, keep URL/DSN setup.
  * Call `NewRepoDb()` with URL/DSN string.
  * Call repo `Open()`; defer repo `Close()`

`gorm` uses connection pools, so doesn't include a direct `Close()` method. I have to get the underlying `sql.DB` and call close on that. But this approach means each repo is opening (and closing) its own connection pool. That may not be a good idea. I need to investigate the consequences of having several repos and connection pools. `gorm`'s `NewRepoDb` may need to be different.

For `dbInMem`, `Open()` and `Close()` just return `nil`. There is nothing to open or close, so they're no-ops.

**COMMIT:** REFACTOR: move ORM/database specific open/close code into repos

## Name changes

Folks in the golang community like short variable, etc., names. I don't, usually. I'm making a pass through the repo code and applying the following changes. I'll apply to other parts of the code later.

* For receivers, aim for names 4 characters or less in lowercase. (This is counter Google practice, but I'm willing to fight on this point.)
* For parameters, use meaningful, spelled out names in camel-case with leading lowercase.
* For function local variables, use meaningful names or abbreviations, but prefer shorter names where possible.
* For other variables, constants and types, use meaningful, spelled out names in camel-case. Choose leading upper/lower casing based on exports.
* For package names, use all lower case with no separators (golang convention).
* For file names, use all lower case with underscore separators where meaningful or significant.
* For directory names, use all lower case with hyphen separators where meaningful or significant.
* For abbreviations, acronyms, initialisms, etc.
  * For multi-term, choose case for whole terms; first term of the name based on exportedness; case as in prose for the rest.
  * For lowercase letter in the term, if not exported, use all lower case, otherwise case first letter based on exportedness and the rest as prose.
  * Google's examples: (XMLAPI, xmlAPI; IOS, iOS; GRPC, gRPC; DDoS, ddos)
  * Exception: Id (identifier), classwords from database or JSON models in certain abbreviated structures
* For `New()` methods, favor `New()` if bound to the thing it's `New`ing (has a receiver); from "reduce repetition" section, which applies elsewhere

**COMMIT:** REFACTOR: apply name changes to repos; ensure tests run and `/cmd/*` has no lint errors

## Move route handler

Decide how server, routes, etc., relate to each other. I'd like to be able to assemble one or many sets of routes in `main` rather than making assumptions in the subdomain. So, I'll probably have `router.go` instead of `server.go` and it may be specific to the subdomain instead of having sub-routers in the subdomain. Decisions about authN/authZ can belong to `main` so I can have different deployables with different behaviors based on what I need. `main` may end up with a companion `server.go` that sets up the details of the server. I may be able to swap `server.go` for the same `main`.

I need to investigate how I might write tests that simulate an HTTP call and what they require so I ensure I separate everything correctly. I should be able to run those tests with mock database, HTTP, etc., connections. (These tests are close to e2e tests.) (`net/http/httptest`)

Registering more than one handler for a route panics, so use the basic pattern below. (Names aren't final.) Handlers come from the packages whose routes are combined in the deployable. Decisions about how to handle different methods (GET, POST, etc.) happen in the handlers.

```golang
// in deployable/main

apiMux := http.NewServeMux()
subMux := http.NewServeMux()

apiMux.Handle("/api", http.StripPrefix("/api", subMux))
subMux.Handle("/job-statuses", jobStatus.Handler)
subMux.Handle("/slo-performances", sloPerf.Handler)  // doesn't exist yet, but for example

// in package

func Handler(res *http.ResponseWriter, req *http.Request) {
  // any pre-checks, body extraction, decoding, etc.
  switch {
    case req.Method == http.MethodGet && req.Query == nil {
      // handle get all
    }
    case req.Method == http.MethodGet && req.Query != nil {
      // handle get by query
    }
    case req.Method == http.MethodPost {
      // handle post
    }
    default {
      // respond not implemented
    }
  }
  // error checks, logging, etc.
}

```

Variations:

* Read-only deployable: Similar to above, but `/api` uses a handler function that accepts `http.MethodGet` only, then calls `subMux.ServeHttp()` to dispatch to package handlers. Same pattern would work for post/put only, etc.
* Package submux with known route: `package.Handler(route)` returns `pkgMux.Handle(route, http.StripPrefix(route, handler))`, allowing a package to handle several subroutes.
* Combining everything: `package.Handler(route, allowedMethods)` returns a submux if `route` isn't empty or a handler if it is. Handlers check `req.Method` is in the list of allowed methods before the `switch`. This might require a `struct` to hold allowed methods, or might be doable with a closure.

I don't need the more complex cases (yet), but want to consider different ways to understand future options.

* Build `init()` for `jobStatus`. What does it return?
  * Creates repo (requires database connection), use case (requires repo), controller (requires use case)
  * The repo part of `init()` is specific to the database type (`sqlpgx` or `gormpg`)
  * I think I'll have different `init()` methods (not try to combine them with a connection type parameter to select repo creation)
* Build router for `jobStatus`. Accept results of `init()` (need controllers).
* Change `cmd/*/main.go`
  * Get handler
  * Add to submux

I need to do some research on how Go builds deployables. I think it includes whole packages and doesn't remove unused packages. If so, I may need to put `init()` in the repo packages so I can avoid importing unneeded repos and their dependencies. If I'm using `database/sql`, I don't want to include `gorm` in the deployable.

<https://stackoverflow.com/questions/59275952/is-it-possible-to-know-which-go-packages-are-installed-in-a-binary>

<https://stackoverflow.com/questions/42825926/how-to-remove-unused-code-at-compile-time> -- suggests the compiler will include packages included in a subpackage, even if they aren't used. I may need to do some experiments. Also need to look at `go build` options (`ldflags` may be interesting).

### Build testing

All locations are in `cmd`. Tests below are the baseline.

| Location | Description | Size |
| -------- | ----------- | ---- |
| `buildtest/minimum`  | returns | 1,284,658 |
| `buildtest/fmt` | `fmt.Println` | 1,802,247 |
| `httpServer-dbpg` | HTTP server for `database/sql` | 12,850,891 |
| `httpServer-gormpg` | HTTP server for `gorm` | 17,031,683 |

**COMMIT:** CHORE: establish baseline for build testing

I'll write two `init()` methods in one file in the `jobStatus` package, one for `dbpg` and one for `gormpg`.

# Interlude -- Reorganize server setup and startup

## Move repos up one level

Repos are in `jobStatus/db/*/repo.go`. I want to remove the `db` layer and prefix `*` with `db` so they're grouped and easier to get to.

* Move directories and renamed.
* Change test import paths. Tests pass.
* Change `cmd` import paths. Run `database/sql`/`pgx`, responses and logs as expected.

**COMMIT:** REFACTOR: move repos up one layer

I want to make the repo `New*()` methods generic so I can use the same call regardless of the repo I select.

* Change repo object to `repoDb` in all repos
* Change repo `New*()` to `NewRepoDb()`; change references in all repos
* Change test import paths. Tests pass.
* Change `cmd` import paths. Run `dbSqlPgx`, responses and logs as expected.

**COMMIT:** REFACTOR: make repo `New*()` methods generic

I want to move the database connection process into each repo so I can use the same call regardless of the ORM I select.

For tests, I need to pass a mock database connection. So, export the database handle `repo.DB`. Then in tests, I can set the database handle to the mock db.

* Change `NewRepoDb()` to accept a DSN string instead of a database connection object.
* Create repo `Open()` and `Close()`; `Open()` requires a pointer receiver so it can set `repo.DB`
* Change tests to set `repo.DB` to the mock.
* In `cmd/*/main.go`
  * Remove database connection code, keep URL/DSN setup.
  * Call `NewRepoDb()` with URL/DSN string.
  * Call repo `Open()`; defer repo `Close()`

`gorm` uses connection pools, so doesn't include a direct `Close()` method. I have to get the underlying `sql.DB` and call close on that. But this approach means each repo is opening (and closing) its own connection pool. That may not be a good idea. I need to investigate the consequences of having several repos and connection pools. `gorm`'s `NewRepoDb` may need to be different.

For `dbInMem`, `Open()` and `Close()` just return `nil`. There is nothing to open or close, so they're no-ops.

**COMMIT:** REFACTOR: move ORM/database specific open/close code into repos

## Name changes

Folks in the golang community like short variable, etc., names. I don't, usually. I'm making a pass through the repo code and applying the following changes. I'll apply to other parts of the code later.

* For receivers, aim for names 4 characters or less in lowercase. (This is counter Google practice, but I'm willing to fight on this point.)
* For parameters, use meaningful, spelled out names in camel-case with leading lowercase.
* For function local variables, use meaningful names or abbreviations, but prefer shorter names where possible.
* For other variables, constants and types, use meaningful, spelled out names in camel-case. Choose leading upper/lower casing based on exports.
* For package names, use all lower case with no separators (golang convention).
* For file names, use all lower case with underscore separators where meaningful or significant.
* For directory names, use all lower case with hyphen separators where meaningful or significant.
* For abbreviations, acronyms, initialisms, etc.
  * For multi-term, choose case for whole terms; first term of the name based on exportedness; case as in prose for the rest.
  * For lowercase letter in the term, if not exported, use all lower case, otherwise case first letter based on exportedness and the rest as prose.
  * Google's examples: (XMLAPI, xmlAPI; IOS, iOS; GRPC, gRPC; DDoS, ddos)
  * Exception: Id (identifier), classwords from database or JSON models in certain abbreviated structures
* For `New()` methods, favor `New()` if bound to the thing it's `New`ing (has a receiver); from "reduce repetition" section, which applies elsewhere

**COMMIT:** REFACTOR: apply name changes to repos; ensure tests run and `/cmd/*` has no lint errors

## Move route handler

Decide how server, routes, etc., relate to each other. I'd like to be able to assemble one or many sets of routes in `main` rather than making assumptions in the subdomain. So, I'll probably have `router.go` instead of `server.go` and it may be specific to the subdomain instead of having sub-routers in the subdomain. Decisions about authN/authZ can belong to `main` so I can have different deployables with different behaviors based on what I need. `main` may end up with a companion `server.go` that sets up the details of the server. I may be able to swap `server.go` for the same `main`.

I need to investigate how I might write tests that simulate an HTTP call and what they require so I ensure I separate everything correctly. I should be able to run those tests with mock database, HTTP, etc., connections. (These tests are close to e2e tests.) (`net/http/httptest`)

Registering more than one handler for a route panics, so use the basic pattern below. (Names aren't final.) Handlers come from the packages whose routes are combined in the deployable. Decisions about how to handle different methods (GET, POST, etc.) happen in the handlers.

```golang
// in deployable/main

apiMux := http.NewServeMux()
subMux := http.NewServeMux()

apiMux.Handle("/api", http.StripPrefix("/api", subMux))
subMux.Handle("/job-statuses", jobStatus.Handler)
subMux.Handle("/slo-performances", sloPerf.Handler)  // doesn't exist yet, but for example

// in package

func Handler(res *http.ResponseWriter, req *http.Request) {
  // any pre-checks, body extraction, decoding, etc.
  switch {
    case req.Method == http.MethodGet && req.Query == nil {
      // handle get all
    }
    case req.Method == http.MethodGet && req.Query != nil {
      // handle get by query
    }
    case req.Method == http.MethodPost {
      // handle post
    }
    default {
      // respond not implemented
    }
  }
  // error checks, logging, etc.
}

```

Variations:

* Read-only deployable: Similar to above, but `/api` uses a handler function that accepts `http.MethodGet` only, then calls `subMux.ServeHttp()` to dispatch to package handlers. Same pattern would work for post/put only, etc.
* Package submux with known route: `package.Handler(route)` returns `pkgMux.Handle(route, http.StripPrefix(route, handler))`, allowing a package to handle several subroutes.
* Combining everything: `package.Handler(route, allowedMethods)` returns a submux if `route` isn't empty or a handler if it is. Handlers check `req.Method` is in the list of allowed methods before the `switch`. This might require a `struct` to hold allowed methods, or might be doable with a closure.

I don't need the more complex cases (yet), but want to consider different ways to understand future options.

* Build `init()` for `jobStatus`. What does it return?
  * Creates repo (requires database connection), use case (requires repo), controller (requires use case)
  * The repo part of `init()` is specific to the database type (`sqlpgx` or `gormpg`)
  * I think I'll have different `init()` methods (not try to combine them with a connection type parameter to select repo creation)
* Build router for `jobStatus`. Accept results of `init()` (need controllers).
* Change `cmd/*/main.go`
  * Get handler
  * Add to submux

I need to do some research on how Go builds deployables. I think it includes whole packages and doesn't remove unused packages. If so, I may need to put `init()` in the repo packages so I can avoid importing unneeded repos and their dependencies. If I'm using `database/sql`, I don't want to include `gorm` in the deployable.

<https://stackoverflow.com/questions/59275952/is-it-possible-to-know-which-go-packages-are-installed-in-a-binary>

<https://stackoverflow.com/questions/42825926/how-to-remove-unused-code-at-compile-time> -- suggests the compiler will include packages included in a subpackage, even if they aren't used. I may need to do some experiments. Also need to look at `go build` options (`ldflags` may be interesting).

### Build testing

Why does built package size matter? Because in a scaled production case, I may want to minimize VM or container/image size for economy. On a same-size/same-quota VM/container, I get more memory available to the program. (Tests below show only a few MB, but as the solution grows, that will increase.) Plus I've read several different statements that seem to conflict slightly, so I want to gather data so I know how it works.

All locations are in `cmd`. Tests below are the baseline.

| Location | Description | Size |
| -------- | ----------- | ---- |
| `buildtest/minimum`  | returns | 1,284,658 |
| `buildtest/fmt` | `fmt.Println` | 1,802,247 |
| `httpServer-dbpg` | HTTP server for `database/sql` | 12,850,891 |
| `httpServer-gormpg` | HTTP server for `gorm` | 17,031,683 |

**COMMIT:** CHORE: establish baseline for build testing

I'll write two `init()` methods in one file in the `jobStatus` package, one for `dbpg` and one for `gormpg`. And there's a problem. Because `init()` needs the repo and the repo needs `jobStatus` stuff, it creates a circular import. So, let's move `init()` into a separate package, `infra`.

When I build `dbpg` with only `InitDbPg()` in `infra/init.go`, it is 12,847,228 vs. 12,850,891 before.

When I add `InitGormPg()` to `infra/init.go`, I get 13,000,566, or about 150KB larger.

When I build `gormpg`, it is 12,999,246, about the same size.

Running `go version -m <built-file-name>` gets the following results

```bash
# For httpServer-dbpg

        dep     github.com/jackc/pgpassfile     v1.0.0  h1:/6Hmqy13Ss2zCq62VdNG8tM1wchn8zjSGOBJ6icpsIM=
        dep     github.com/jackc/pgservicefile  v0.0.0-20221227161230-091c0ba34f0a      h1:bbPeKD0xmW/Y25WS6cokEszi5g+S0QxI/d45PkRi7Nk=
        dep     github.com/jackc/pgx/v5 v5.4.1  h1:oKfB/FhuVtit1bBM3zNRRsZ925ZkMN3HXL+LgLUM9lE=
        dep     github.com/jinzhu/inflection    v1.0.0  h1:K317FqzuhWc8YvSVlFMCCUb36O/S9MCKRDI7QkRKD/E=
        dep     github.com/jinzhu/now   v1.1.5  h1:/o9tlHleP7gOFmsnYNz3RGnqzefHA47wQpKrrdTIwXQ=
        dep     golang.org/x/crypto     v0.9.0  h1:LF6fAI+IutBocDJ2OT0Q1g8plpYljMZ4+lty+dsqw3g=
        dep     golang.org/x/text       v0.9.0  h1:2sjJmO8cDvYveuX97RDLsxlyUxLl+GHoLxBiRdHllBE=
        dep     gorm.io/driver/postgres v1.5.2  h1:ytTDxxEv+MplXOfFe3Lzm7SjG09fcdb3Z/c056DTBx0=
        dep     gorm.io/gorm    v1.25.2 h1:gs1o6Vsa+oVKG/a9ElL3XgyGfghFfkKA2SInQaCyMho=

# For httpServer-gormpg
        dep     github.com/jackc/pgpassfile     v1.0.0  h1:/6Hmqy13Ss2zCq62VdNG8tM1wchn8zjSGOBJ6icpsIM=
        dep     github.com/jackc/pgservicefile  v0.0.0-20221227161230-091c0ba34f0a      h1:bbPeKD0xmW/Y25WS6cokEszi5g+S0QxI/d45PkRi7Nk=
        dep     github.com/jackc/pgx/v5 v5.4.1  h1:oKfB/FhuVtit1bBM3zNRRsZ925ZkMN3HXL+LgLUM9lE=
        dep     github.com/jinzhu/inflection    v1.0.0  h1:K317FqzuhWc8YvSVlFMCCUb36O/S9MCKRDI7QkRKD/E=
        dep     github.com/jinzhu/now   v1.1.5  h1:/o9tlHleP7gOFmsnYNz3RGnqzefHA47wQpKrrdTIwXQ=
        dep     golang.org/x/crypto     v0.9.0  h1:LF6fAI+IutBocDJ2OT0Q1g8plpYljMZ4+lty+dsqw3g=
        dep     golang.org/x/text       v0.9.0  h1:2sjJmO8cDvYveuX97RDLsxlyUxLl+GHoLxBiRdHllBE=
        dep     gorm.io/driver/postgres v1.5.2  h1:ytTDxxEv+MplXOfFe3Lzm7SjG09fcdb3Z/c056DTBx0=
        dep     gorm.io/gorm    v1.25.2 h1:gs1o6Vsa+oVKG/a9ElL3XgyGfghFfkKA2SInQaCyMho=
```

So, both include `gorm`.

If I remove `InitGormPg` and it's dependencies, I get the following for `dbpg`.

```bash
        dep     github.com/jackc/pgpassfile     v1.0.0  h1:/6Hmqy13Ss2zCq62VdNG8tM1wchn8zjSGOBJ6icpsIM=
        dep     github.com/jackc/pgservicefile  v0.0.0-20221227161230-091c0ba34f0a      h1:bbPeKD0xmW/Y25WS6cokEszi5g+S0QxI/d45PkRi7Nk=
        dep     github.com/jackc/pgx/v5 v5.4.1  h1:oKfB/FhuVtit1bBM3zNRRsZ925ZkMN3HXL+LgLUM9lE=
        dep     golang.org/x/crypto     v0.9.0  h1:LF6fAI+IutBocDJ2OT0Q1g8plpYljMZ4+lty+dsqw3g=
        dep     golang.org/x/text       v0.9.0  h1:2sjJmO8cDvYveuX97RDLsxlyUxLl+GHoLxBiRdHllBE=
```

So, one observation is that `gorm` only adds about 150KB to the output, which seems odd. But I'm cautious about including code I don't need from a security perspective. (LATER: because `gormpg` was calling the `init()` for `dbpg`.)

Let's do some tests with `-ldflags "-s -w"`, which omit the symbol table and debug information and omit the DWARF (more debugger) symbol table, per [docs](https://pkg.go.dev/cmd/link).

`dbpg` no `gorm` -- 8,843,264 (about 4MB smaller than original)
`dbpg` with `gorm` -- 8,949,760 (about 100KB larger)
`gormpg` -- 8,949,760 (proves previous includes `gorm` components) -- actually, this may be invalid because I later saw I was calling the wrong `init()`

Let's try with `infra_gormpg` and `infra_dbpg` so the `init()` methods are separated.

`dbpg` -- 8,843,264 (same as above)
`dbpg` with `InitGormPg` -- 8,949,760 (`gorm` is definitely adding some overhead)
`gormpg` -- 11,763,712 (building with `InitDbPg()` in `init.go` but not called does not change size)

I also tried putting `InitGormPg()` in a separate file in `infra_dbpg`. The build size is still 8,949,760.

Conclusions:

* If a package includes something, it gets linked (because `dbpg` with and without `gorm` gets different sizes)
* But it may not link everything (because `gormpg` calling `InitGormDb` is ~2.8MB larger than `dbpg` with `InitGormPg()` present but not called)

I'm going to try to lay it out like this:

```

| | |-infra
| | | |-dbpg
| | | | |-modinit.go
| | | |-gormpg
| | | | |-modinit.go
| | | |-router.go
```

I changed the package to `modinit` because `init()` is a special function in Golang (runs before `main()`), so I can't use that name for the import.

This directory structure lets me import what I need without extra and lets me put the router setup in `infra` too. I may call `router.go` something that indicates `http`.

**COMMIT:** REFACTOR: create and use `Init()` method for dbpg and gormpg

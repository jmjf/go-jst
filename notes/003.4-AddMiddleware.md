# Server -- Add middleware

## Add trace id

I want to assign a unique identifier to each request and make it available for logging so I can track the request through the system for debugging and issue investigation.

I want to log the request identifier for all logs related to the request.

In Golang, middleware is a function that returns a `HandlerFunc` that is the middleware. The function accepts an `http.Handler`, usually called `next`. The middleware should hand off to the next thing in the chain by calling `next.ServeHttp(res, req)`, where `res` is the `http.ResponseWriter` and `req` is the `*http.Request` (both received by the middleware).

This pattern isn't that different from Express in NodeJS, except Express middleware accepts `next`, `req`, and `res` in one function.

To assign a unique identifier, I need a source for it. A quick search for options makes me lean toward `segmentio/ksuid` because it's time ordered. Host and process id information will be in logs, so I don't need to add them. For first pass, I'll just increment.

```golang
// addRequestId returns a middleware handler that assigns a request id to the request's context.
func addRequestId(next http.Handler) http.Handler{
   reqId uint64 := 1
   return http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
      ctx := context.WithValue(req.Context(), "requestId" , reqId)
      reqId++
      next.ServeHTTP(res, req.WithContext(ctx))
   })
}
```

In other places where I want to log the request id, `requestId := req.Context().Value("requestId")`.

One issue is, context doesn't support type checking (it's `any`), so I may want to extend this with a `type RequestId struct { RequestId uint64 }`, add a getter and setter. Then in the middleware, `ctx := setRequestId(req.Context, &RequestId{ RequestId: reqId })` and `requestId := getRequestId(req.Context)`. Roughly. Think about naming, etc. [ref](https://fideloper.com/golang-context-http-middleware) That detail may be overkill, but in a larger team or with a larger audience, it might be valuable to help ensure consistency.

I'll put middleware in `/lib/middleware`, each middleware in a separate file. For now, I'll make it one package, but may make separate packages later so I don't import unneeded middleware.

To use the middleware, in the server (`cmd/httpServer-dbpg/main.go`)

```
 mux := http.NewServeMux()
 apiMux := http.NewServeMux()

 apiMux.Handle("/job-statuses", jshttp.Handler(logger, addCtrl))
 apiMux.Handle("/job-statuses/", jshttp.Handler(logger, addCtrl))
 mux.Handle("/api/", http.StripPrefix("/api", middleware.AddRequestId(apiMux)))
 mux.Handle("/", logHandler(logger, "/"))
```

While working on this, I figured out how to use a submux. It requires a trailing slash on the upper route: `apiMux.Handle("/api/", http.StripPrefix("/api", handler))`.

I think I have it wired correctly. Now, in the handler that calls the controller, I need to add the request id to the logger (with route and method) so the controller gets the request id.

I added `const requestIdKey` to provide a single control point for the request id's key in the context. I also added `middleware.GetRequestId(ctx context.Context)` to conceal details of how the request id is retrieved. It isn't complex, but the function hides internals and makes the code intent clearer. The function returns 0 if it can't get the request id.

The code is working. I see request id in the log output and it's incrementing.

For now, I'm only putting these changes in `httpServer-dbpg`. I'll add it to `httpServer-gormpg` either after all is done or after pulling the server setup and main into `/internal/jobStatus/cmd`.

**COMMIT:** FEAT: add request id to requests for traceability

## Request logger

I want to log requests received and replied and track request execution time so I can ensure all requests are handled properly, identify invalid requests, and better monitor the system's behavior.

The request logger will need a copy of the application's logger. Output should include the following data.

* `Request.RemoteAddr string`
* `Request.RequestURI string`
* `Request.Method string`
* `RequestId uint64`
* `ReceivedTime time.Time`

I set `const requestLogLevel` so it's easy to change the request log's level. I may test with it at Info but run with it at Debug or Trace to limit log volume. The middleware checks if the logger's handler is enabled for the target level and, if not, doesn't try to log (reduces overhead).

The outer function around the middleware handler accepts both the next handler and the logger.

I have the request and response logging but getting to the response to log response status code and content length is apparently challenging in Golang because it's in the `http.ResponseWriter`. I'll need to do some digging. Most solutions I'm seeing require some new knowledge (parts of stdlib I haven't used yet).

Also, look at how to restructure the code using `defer` to do the response logging. (I'll need to put the logging inside an `if`.)

**COMMIT:** FEAT: Add request logging middleware

## Logging responses

I want to log data about responses returned and track execution time so I have information about successful and failed requests and failure reasons.

I want the response status code and content length at a minimum, possibly more.

Golang doesn't give me direct access to a response with data, it gives a `ResponseWriter`, which is aimed at writing. `ResponseWriter` is an interface with three methods, none of which lend themselves to getting the response details I want.

The cannonical solution seems to be to write a wrapper for `ResponseWriter` with methods that capture data on the wrapper when called and pass the call on to the `ResponseWriter` in the wrapper. The basic version is below.

```golang
type resWriter struct {
 http.ResponseWriter
 status int
 contentLength int
}

func (rw *resWriter) WriteHeader(code int) {
 rw.status = code
 rw.ResponseWriter.WriteHeader(code)
}

func (rw *resWriter) Write(data []byte) (int, error) {
 rw.contentLength += len(data)
 return rw.ResponseWriter.Write(data)
}

func wrapResponseWriter(res http.ResponseWriter) *resWriter {
 return &resWriter{ResponseWriter: res, contentLength: 0}
}
```

There's a package called `httpsnoop` that handles wrapping. The package's readme says wrappers can be a problem because they may miss interfaces that the object behind the `ResponseWriter` implements. [This post](https://blog.kowalczyk.info/article/e00e89c3841e4f8c8c769a78b8a90b47/logging-http-requests-in-go.html) also mentions that the client's IP may be masked by a proxy and outlines ways to get it.

Another option might be to use `httptest.ResponseRecorder`. This type has status, headers, and body available, but I think that would mean taking the data from it and writing it to the real `ResponseWriter`. This approach seems like it will introduce a lot of overhead.

The simple wrapper solution works. I want to understand some of the complexity `httpsnoop` handles and get a better understanding of what might break.

**COMMIT:** FEAT: add status code and content length to response logging with a ResponseWriter wrapper

## Track request stats

I want to accumulate by route and method, total request counts, execution times, success/failure counts, etc., so I can better monitor the system.

I'll use a map with method + route as the key with a `|` separator (example, `POST|/api/job-statuses`). Map entries will be a `struct` (below). In the future, I'll need a mutex in the `struct` if I run parallel request handling.

```golang
type RouteStats struct {
   RequestCount int
   TotalExecTime time.Duration
   Status200Count int   // 200-series statuses
   Status400Count int   // 400-series statuses
   Status500Count int   // 500-series statuses
}
```

~~I want to expand status to include moving window totals for the last hour so I can better monitor the system.~~

Log analysis is a better answer--for both cases, really. But I'll add the basic stats tracker because it's simple and I don't plan to spin up log query tool soon.

The stats tracker needs the response status code. That means it needs to wrap the `ResponseWriter`. If I combine this with `log-request`, I end up with a double wrapped `ResponseWriter`, which seems like a bad idea. The simple answer is to put status tracking in `log-request`. I'm not sure that's wise because it makes `log-request` do more than request logging. On the other hand, I want the time calculated in `log-request` here too, so that may be less unwise than it seems. For now, I'll put stats tracking in `log-request` as separate functions the request logger middleware calls. Doing so makes it clear it's a separate function and makes it easier to remove later if I want to remove it. I'll accept that requests are counted only after the response. (Not perfect, but good enough.)

I'm glad I did that. It revealed that the controller was returning status 0 for ok cases. The server is returning 200, but I'd rather choose my return status and not assume. Added an explicit `WriteHeader(http.StatusOK)` for the ok case.

**COMMIT:** FEAT: add basic per-route statistics tracking (to be replaced in the future)

While working on this section, I decided to rename `CommonError` to `LoggableError` because the latter name better reflects the intent--to provide an error with data that can be logged, mainly within the context of structured logging.

**COMMIT:** REFACTOR: rename CommonError to LoggableError (clearer intent)

## Add a middleware error and return it when "Get" methods fail

I want to return an error when middleware "Get" methods fail so I can safely identify and respond to failures.

As part of this change, I want to move the `lib/middleware` directory to `internal/middleware` because I think this code is less public/reusable (for now) than I thought.

Added `ErrMWGetReqId` and code to `internal/errors.go`. Added error return in `log-request.go` and error logging in functions that use `GetRequestId()`.

**COMMIT:** REFACTOR: add error return for GetRequestId() and handle/log in places that call it

## Generate unique request ids

I want to generate unique request ids so I can identify specific requests across runs and hosts (in a multi-host scenario).

I'm learning toward `segmentio/ksuid`, but may investigate other options.

## Find a better way to pass the application's logger to the LogRequest middleware

I want to find a better way to pass the logger to the `LogRequest` middleware so it's easier and less error prone to wrap the middleware.
